{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pgdoorman-postgresql-pooler","title":"PgDoorman: PostgreSQL Pooler","text":"<p>PgDoorman is a stable and good alternative to PgBouncer, Odyssey, or PgCat (based on it). It has created with the Unix philosophy in mind. Developing was focused on perfomance, efficience and reliability. Also, PgDoorman has the improved driver support for languages like Go (pgx), .NET (npgsql), and asynchronous drivers for Python and Node.js.</p> <p> Get PgDoorman 2.2.2</p>"},{"location":"#why-not-multi-pgbouncer","title":"Why not multi-PgBouncer?","text":"<p>Why do we think that using multiple instances of PgBouncer is not a suitable solution? This approach has problems with reusing prepared statements and strange and inefficient control over query cancellation. Additionally, the main issue we have encountered is that the operating system distributes new clients round-robin, but each client can disconnect at any time, leading to an imbalance after prolonged use.</p>"},{"location":"#why-not-odyssey","title":"Why not Odyssey?","text":"<p>We had difficulties using NPGSQL and SCRAM, as well as with <code>prepared_statements</code> support. However, the main serious problem related to data consistency and, for a long time, we were unable to solve it.</p>"},{"location":"#differences-from-pgcat","title":"Differences from PgCat","text":"<p>While PgDoorman was initially based on the PgCat project, it has since evolved into a standalone solution with its own set of features. Some of the key differences include:</p> <ul> <li>Performance improvements compared to PgCat/PgBouncer/Odyssey.</li> <li>Support for extended protocol with popular programming language drivers.</li> <li>Enhanced monitoring metrics to improve visibility into database activity..</li> <li>Careful resource management to avoid memory issues (<code>max_memory_usage</code>, <code>message_size_to_be_stream</code>).</li> <li>SCRAM client/server authentication support.</li> <li>Gracefully binary upgrade.</li> <li>Supporting JWT for service-to-database authentication.</li> <li>Many micro-optimizations (for example, the time spent with the client is longer than the server's busy time).</li> </ul>"},{"location":"benchmarks/","title":"Performance Benchmarks","text":""},{"location":"benchmarks/#introduction","title":"Introduction","text":"<p>Performance benchmarks provide valuable insights into the operational characteristics of connection poolers. While these benchmarks offer a comparative view of different poolers, we strongly recommend conducting your own tests in an environment that matches your production setup for the most accurate results.</p> <p>The benchmarks presented here are designed to: - Compare PgDoorman with other popular PostgreSQL connection poolers - Demonstrate performance under different workload scenarios - Highlight the resource utilization patterns of each pooler</p>"},{"location":"benchmarks/#testing-environment","title":"Testing Environment","text":"<p>All benchmarks were conducted with the following configuration: - PostgreSQL 15 - Server with 20 CPU cores - Connection pool size: 40 connections - Client authentication: SCRAM - Testing tool: pgbench - Test duration: 600 seconds (10 minutes) - Client connections: 80 - Job parallelism: 4</p>"},{"location":"benchmarks/#benchmark-scenarios","title":"Benchmark Scenarios","text":""},{"location":"benchmarks/#1-prepared-statements-without-ssl","title":"1. Prepared Statements without SSL","text":"<p>This scenario tests the performance of prepared statements execution without SSL encryption.</p> <p>Command: <pre><code>PGSSLMODE=disable pgbench -s 10 -T 600 -P 1 -S -n -j 4 -c 80 -M prepared -r\n</code></pre></p> <p>Results:</p> Pooler CPU Usage Transactions Per Second PostgreSQL - 230,000 PgBouncer 1 core 45,000 Odyssey 5-6 cores 125,000 PgCat - Not available* PgDoorman 6-7 cores 135,000 <p>*Note: PgCat (version 1.3.0) was configured with <code>prepared_statements_cache_size = 500</code>, but prepared statements with pgbench were not functioning correctly.</p>"},{"location":"benchmarks/#2-simple-queries-without-ssl","title":"2. Simple Queries without SSL","text":"<p>This scenario tests the performance of simple queries without SSL encryption.</p> <p>Command: <pre><code>PGSSLMODE=disable pgbench -s 10 -T 600 -P 1 -S -n -j 4 -c 80 -r\n</code></pre></p> <p>Results:</p> Pooler CPU Usage Transactions Per Second PostgreSQL - 150,000 PgBouncer 1 core 60,000 Odyssey 4 cores 105,000 PgCat 3-4 cores 85,000 PgDoorman 4-5 cores 110,000"},{"location":"benchmarks/#3-reconnect-performance-with-ssl","title":"3. Reconnect Performance with SSL","text":"<p>This scenario tests the connection establishment rate with SSL encryption enabled.</p> <p>Command: <pre><code>PGSSLMODE=require pgbench -s 10 -T 600 -P 1 -S -n -j 4 -c 80 -M prepared -r -C\n</code></pre></p> <p>Results:</p> Pooler CPU Usage Connections Per Second PostgreSQL - 190 PgBouncer 1 core 240 Odyssey 1 core 260* PgCat 1 core 530** PgDoorman 1 core 260 <p>Notes: * Odyssey occasionally produced authentication errors: <code>error: connection to server at \"10.251.28.154\", port 6432 failed: ERROR: odyssey: c3d386c5e5c2f: password authentication failed</code>. * *PgCat (using rustls) showed higher connection rates than PgDoorman (using OpenSSL), but we encountered compatibility issues with rustls when using certain client drivers like npgsql, which led us to adopt OpenSSL wrappers instead.</p>"},{"location":"benchmarks/#conclusion","title":"Conclusion","text":"<p>These benchmarks demonstrate that PgDoorman offers competitive performance compared to other PostgreSQL connection poolers. While it may use more CPU resources in some scenarios, it delivers higher throughput, particularly for prepared statements and simple queries.</p> <p>When selecting a connection pooler, consider not only raw performance but also stability, feature set, and compatibility with your specific application stack.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#2.2.2","title":"2.2.2 Aug 17, 2025","text":"<p>Features: - Added new generate feature functionality</p> <p>Bug Fixes: - Fixed deallocate issues with PGX5 compatibility</p>"},{"location":"changelog/#2.2.1","title":"2.2.1 Aug 6, 2025","text":"<p>Features: - Improve Prometheus exporter functionality</p>"},{"location":"changelog/#2.2.0","title":"2.2.0 Aug 5, 2025","text":"<p>Features: - Added Prometheus exporter functionality that provides metrics about connections, memory usage, pools, queries, and transactions</p>"},{"location":"changelog/#2.1.2","title":"2.1.2 Aug 4, 2025","text":"<p>Features: - Added docker image <code>ghcr.io/ozontech/pg_doorman</code></p>"},{"location":"changelog/#2.1.0","title":"2.1.0 Aug 1, 2025","text":"<p>Features: - The new command <code>generate</code> connects to your PostgreSQL server, automatically detects all databases and users, and creates a complete configuration file with appropriate settings. This is especially useful for quickly setting up PgDoorman in new environments or when you have many databases and users to configure.</p>"},{"location":"changelog/#2.0.1","title":"2.0.1 July 24, 2025","text":"<p>Bug Fixes: - Fixed <code>max_memory_usage</code> counter leak when clients disconnect improperly.</p>"},{"location":"changelog/#2.0.0","title":"2.0.0 July 22, 2025","text":"<p>Features: - Added <code>tls_mode</code> configuration option to enhance security with flexible TLS connection management and client certificate validation capabilities.</p>"},{"location":"changelog/#1.9.0","title":"1.9.0 July 20, 2025","text":"<p>Features: - Added PAM authentication support. - Added <code>talos</code> JWT authentication support.</p> <p>Improvements: - Implemented streaming for COPY protocol with large columns to prevent memory exhaustion. - Updated Rust and Tokio dependencies.</p>"},{"location":"changelog/#1.8.3","title":"1.8.3 Jun 11, 2025","text":"<p>Bug Fixes: - Fixed critical bug where Client's buffer wasn't cleared when no free connections were available in the Server pool (query_wait_timeout), leading to incorrect response errors. #38 - Fixed Npgsql-related issue. Npgsql#6115</p>"},{"location":"changelog/#1.8.2","title":"1.8.2 May 24, 2025","text":"<p>Features: - Added <code>application_name</code> parameter in pool. #30 - Added support for <code>DISCARD ALL</code> and <code>DEALLOCATE ALL</code> client queries.</p> <p>Improvements: - Implemented link-time optimization. #29</p> <p>Bug Fixes: - Fixed panics in admin console. - Fixed connection leakage on improperly handled errors in client's copy mode.</p>"},{"location":"changelog/#1.8.1","title":"1.8.1 April 12, 2025","text":"<p>Bug Fixes: - Fixed config value of prepared_statements. #21 - Fixed handling of declared cursors closure. #23 - Fixed proxy server parameters. #25</p>"},{"location":"changelog/#1.8.0","title":"1.8.0 Mar 20, 2025","text":"<p>Bug Fixes: - Fixed dependencies issue. #15</p> <p>Improvements: - Added release vendor-licenses.txt file. Related thread</p>"},{"location":"changelog/#1.7.9","title":"1.7.9 Mar 16, 2025","text":"<p>Improvements: - Added release vendor.tar.gz for offline build. Related thread</p> <p>Bug Fixes: - Fixed issues with pqCancel messages over TLS protocol. Drivers should send pqCancel messages exclusively via TLS if the primary connection was established using TLS. Npgsql follows this rule, while PGX currently does not. Both behaviors are now supported.</p>"},{"location":"changelog/#1.7.8","title":"1.7.8 Mar 8, 2025","text":"<p>Bug Fixes: - Fixed message ordering issue when using batch processing with the extended protocol. - Improved error message detail in logs for server-side login attempt failures.</p>"},{"location":"changelog/#1.7.7","title":"1.7.7 Mar 8, 2025","text":"<p>Features: - Enhanced <code>show clients</code> command with new fields: <code>state</code> (waiting/idle/active) and <code>wait</code> (read/write/idle). - Enhanced <code>show servers</code> command with new fields: <code>state</code> (login/idle/active), <code>wait</code> (read/write/idle), and <code>server_process_pid</code>. - Added 15-second proxy timeout for streaming large <code>message_size_to_be_stream</code> responses.</p> <p>Bug Fixes: - Fixed <code>max_memory_usage</code> counter leak when clients disconnect improperly.</p>"},{"location":"reference/general/","title":"Settings","text":""},{"location":"reference/general/#general-settings","title":"General Settings","text":""},{"location":"reference/general/#host","title":"host","text":"<p>Listen host (TCP v4 only).</p> <p>Default: <code>\"0.0.0.0\"</code>.</p>"},{"location":"reference/general/#port","title":"port","text":"<p>Listen port for incoming connections.</p> <p>Default: <code>6432</code>.</p>"},{"location":"reference/general/#backlog","title":"backlog","text":"<p>TCP backlog for incoming connections. A value of zero sets the <code>max_connections</code> as value for the TCP backlog.</p> <p>Default: <code>0</code>.</p>"},{"location":"reference/general/#max_connections","title":"max_connections","text":"<p>The maximum number of clients that can connect to the pooler simultaneously. When this limit is reached: * A client connecting without SSL will receive the expected error (code: <code>53300</code>, message: <code>sorry, too many clients already</code>). * A client connecting via SSL will see a message indicating that the server does not support the SSL protocol.</p> <p>Default: <code>8192</code>.</p>"},{"location":"reference/general/#tls_mode","title":"tls_mode","text":"<p>The TLS mode for incoming connections. It can be one of the following:</p> <ul> <li><code>allow</code> - TLS connections are allowed but not required. The pg_doorman will attempt to establish a TLS connection if the client requests it.</li> <li><code>disable</code> - TLS connections are not allowed. All connections will be established without TLS encryption.</li> <li><code>require</code> - TLS connections are required. The pg_doorman will only accept connections that use TLS encryption.</li> <li><code>verify-full</code> - TLS connections are required and the pg_doorman will verify the client certificate. This mode provides the highest level of security.</li> </ul> <p>Default: <code>\"allow\"</code>.</p>"},{"location":"reference/general/#tls_ca_file","title":"tls_ca_file","text":"<p>The file containing the CA certificate to verify the client certificate. This is required when <code>tls_mode</code> is set to <code>verify-full</code>.</p> <p>Default: <code>None</code>.</p>"},{"location":"reference/general/#tls_private_key","title":"tls_private_key","text":"<p>The path to the private key file for TLS connections. This is required to enable TLS for incoming client connections. Must be used together with <code>tls_certificate</code>.</p> <p>Default: <code>None</code>.</p>"},{"location":"reference/general/#tls_certificate","title":"tls_certificate","text":"<p>The path to the certificate file for TLS connections. This is required to enable TLS for incoming client connections. Must be used together with <code>tls_private_key</code>.</p> <p>Default: <code>None</code>.</p>"},{"location":"reference/general/#tls_rate_limit_per_second","title":"tls_rate_limit_per_second","text":"<p>Limit the number of simultaneous attempts to create a TLS session. Any value other than zero implies that there is a queue through which clients must pass in order to establish a TLS connection. In some cases, this is necessary in order to launch an application that opens many connections at startup (the so-called \"hot start\").</p> <p>Default: <code>0</code>.</p>"},{"location":"reference/general/#daemon_pid_file","title":"daemon_pid_file","text":"<p>Enabling this setting enables daemon mode. Comment this out if you want to run pg_doorman in the foreground with <code>-d</code>.</p> <p>Default: <code>None</code>.</p>"},{"location":"reference/general/#syslog_prog_name","title":"syslog_prog_name","text":"<p>When specified, pg_doorman starts sending messages to syslog (using /dev/log or /var/run/syslog). Comment this out if you want to log to stdout.</p> <p>Default: <code>None</code>.</p>"},{"location":"reference/general/#log_client_connections","title":"log_client_connections","text":"<p>Log client connections for monitoring.</p> <p>Default: <code>true</code>.</p>"},{"location":"reference/general/#log_client_disconnections","title":"log_client_disconnections","text":"<p>Log client disconnections for monitoring.</p> <p>Default: <code>true</code>.</p>"},{"location":"reference/general/#worker_threads","title":"worker_threads","text":"<p>The number of worker processes (posix threads) that async serve clients, which affects the performance of pg_doorman. The more workers there are, the faster the system works, but only up to a certain limit (cpu count). If you already have a lot of workers, you should consider increasing the number of virtual pools.</p> <p>Default: <code>4</code>.</p>"},{"location":"reference/general/#worker_cpu_affinity_pinning","title":"worker_cpu_affinity_pinning","text":"<p>Automatically assign workers to different CPUs (man 3 cpu_set).</p> <p>Default: <code>false</code>.</p>"},{"location":"reference/general/#virtual_pool_count","title":"virtual_pool_count","text":"<p>Increasing the number of virtual pools can help deal with internal latches that occur when processing very large numbers of fast queries. It is strongly recommended not to change this parameter if you do not understand what you are doing.</p> <p>Default: <code>1</code>.</p>"},{"location":"reference/general/#tokio_global_queue_interval","title":"tokio_global_queue_interval","text":"<p>Tokio runtime settings. It is strongly recommended not to change this parameter if you do not understand what you are doing.</p> <p>Default: <code>5</code>.</p>"},{"location":"reference/general/#tokio_event_interval","title":"tokio_event_interval","text":"<p>Tokio runtime settings. It is strongly recommended not to change this parameter if you do not understand what you are doing.</p> <p>Default: <code>1</code>.</p>"},{"location":"reference/general/#worker_stack_size","title":"worker_stack_size","text":"<p>Tokio runtime settings. It is strongly recommended not to change this parameter if you do not understand what you are doing.</p> <p>Default: <code>8388608</code>.</p>"},{"location":"reference/general/#connect_timeout","title":"connect_timeout","text":"<p>Connection timeout to server in milliseconds.</p> <p>Default: <code>3000</code> (3 sec).</p>"},{"location":"reference/general/#query_wait_timeout","title":"query_wait_timeout","text":"<p>Maximum time to wait for a query to complete, in milliseconds.</p> <p>Default: <code>5000</code> (5 sec).</p>"},{"location":"reference/general/#idle_timeout","title":"idle_timeout","text":"<p>Server idle timeout in milliseconds.</p> <p>Default: <code>300000000</code> (5000 min).</p>"},{"location":"reference/general/#server_lifetime","title":"server_lifetime","text":"<p>Server lifetime in milliseconds.</p> <p>Default: <code>300000</code> (5 min).</p>"},{"location":"reference/general/#server_round_robin","title":"server_round_robin","text":"<p>In transactional pool mode, we can choose whether the last free server backend will be used or the next one will be selected. By default, the LRU (Least Recently Used) method is used, which has a positive impact on performance.</p> <p>Default: <code>false</code>.</p>"},{"location":"reference/general/#sync_server_parameters","title":"sync_server_parameters","text":"<p>If enabled, we strive to restore the parameters (via query <code>SET</code>) that were set by the client (and application_name) in transaction mode in other server backends. By default, this is disabled (false) due to performance. If you need to know <code>application_name</code>, but don't want to experience performance issues due to constant server queries <code>SET</code>, you can consider creating a separate pool for each application and using the <code>application_name</code> parameter in the <code>pool</code> settings.</p> <p>Default: <code>false</code>.</p>"},{"location":"reference/general/#tcp_so_linger","title":"tcp_so_linger","text":"<p>By default, pg_doorman send <code>RST</code> instead of keeping the connection open for a long time.</p> <p>Default: <code>0</code>.</p>"},{"location":"reference/general/#tcp_no_delay","title":"tcp_no_delay","text":"<p>TCP_NODELAY to disable Nagle's algorithm for lower latency.</p> <p>Default: <code>true</code>.</p>"},{"location":"reference/general/#tcp_keepalives_count","title":"tcp_keepalives_count","text":"<p>Keepalive enabled by default and overwrite OS defaults.</p> <p>Default: <code>5</code>.</p>"},{"location":"reference/general/#tcp_keepalives_idle","title":"tcp_keepalives_idle","text":"<p>Default: <code>5</code>.</p>"},{"location":"reference/general/#tcp_keepalives_interval","title":"tcp_keepalives_interval","text":"<p>Default: <code>1</code>.</p>"},{"location":"reference/general/#unix_socket_buffer_size","title":"unix_socket_buffer_size","text":"<p>Buffer size for read and write operations when connecting to PostgreSQL via a unix socket.</p> <p>Default: <code>1048576</code>.</p>"},{"location":"reference/general/#admin_username","title":"admin_username","text":"<p>Access to the virtual admin database is carried out through the administrator's username and password.</p> <p>Default: <code>\"admin\"</code>.</p>"},{"location":"reference/general/#admin_password","title":"admin_password","text":"<p>Access to the virtual admin database is carried out through the administrator's username and password. It should be replaced with your secret.</p> <p>Default: <code>\"admin\"</code>.</p>"},{"location":"reference/general/#prepared_statements","title":"prepared_statements","text":"<p>Switcher to enable/disable caching of prepared statements.</p> <p>Default: <code>true</code>.</p>"},{"location":"reference/general/#prepared_statements_cache_size","title":"prepared_statements_cache_size","text":"<p>Cache size of prepared requests on the server side.</p> <p>Default: <code>8192</code>.</p>"},{"location":"reference/general/#message_size_to_be_stream","title":"message_size_to_be_stream","text":"<p>Data responses from the server (message type 'D') greater than this value will be transmitted through the proxy in small chunks (1 MB).</p> <p>Default: <code>1048576</code>.</p>"},{"location":"reference/general/#max_memory_usage","title":"max_memory_usage","text":"<p>We calculate the total amount of memory used by the internal buffers for all current queries. If the limit is reached, the client will receive an error (256 MB).</p> <p>Default: <code>268435456</code>.</p>"},{"location":"reference/general/#shutdown_timeout","title":"shutdown_timeout","text":"<p>With a graceful shutdown, we wait for transactions to be completed within this time limit (10 seconds).</p> <p>Default: <code>10000</code>.</p>"},{"location":"reference/general/#proxy_copy_data_timeout","title":"proxy_copy_data_timeout","text":"<p>Maximum time to wait for data copy operations during proxying, in milliseconds.</p> <p>Default: <code>15000</code> (15 sec).</p>"},{"location":"reference/general/#server_tls","title":"server_tls","text":"<p>Enable TLS for connections to the PostgreSQL server. When enabled, pg_doorman will attempt to establish TLS connections to the backend PostgreSQL servers.</p> <p>Default: <code>false</code>.</p>"},{"location":"reference/general/#verify_server_certificate","title":"verify_server_certificate","text":"<p>Verify the PostgreSQL server's TLS certificate when connecting with TLS. This setting is only relevant when <code>server_tls</code> is enabled.</p> <p>Default: <code>false</code>.</p>"},{"location":"reference/general/#hba","title":"hba","text":"<p>The list of IP addresses from which it is permitted to connect to the pg-doorman.</p>"},{"location":"reference/general/#pooler_check_query","title":"pooler_check_query","text":"<p>This query will not be sent to the server if it is run as a SimpleQuery. It can be used to check the connection at the application level.</p> <p>Default: <code>;</code>.</p>"},{"location":"reference/pool/","title":"Pool Settings","text":""},{"location":"reference/pool/#pool-settings","title":"Pool Settings","text":"<p>Each record in the pool is the name of the virtual database that the pg-doorman client can connect to.</p> <pre><code>[pools.exampledb] # Declaring the 'exampledb' database\n</code></pre>"},{"location":"reference/pool/#server_host","title":"server_host","text":"<p>The directory with unix sockets or the IPv4 address of the PostgreSQL server that serves this pool.</p> <p>Example: <code>\"/var/run/postgresql\"</code> or <code>\"127.0.0.1\"</code>.</p>"},{"location":"reference/pool/#server_port","title":"server_port","text":"<p>The port through which PostgreSQL server accepts incoming connections.</p> <p>Default: <code>5432</code>.</p>"},{"location":"reference/pool/#server_database","title":"server_database","text":"<p>Optional parameter that determines which database should be connected to on the PostgreSQL server.</p> <p>Example: <code>\"exampledb-2\"</code></p>"},{"location":"reference/pool/#application_name","title":"application_name","text":"<p>Parameter application_name, is sent to the server when opening a connection with PostgreSQL. It may be useful with the sync_server_parameters = false setting.</p> <p>Example: <code>\"exampledb-pool\"</code></p>"},{"location":"reference/pool/#connect_timeout","title":"connect_timeout","text":"<p>Maximum time to allow for establishing a new server connection for this pool, in milliseconds. If not specified, the global connect_timeout setting is used.</p> <p>Default: <code>None</code> (uses global setting).</p>"},{"location":"reference/pool/#idle_timeout","title":"idle_timeout","text":"<p>Close idle connections in this pool that have been opened for longer than this value, in milliseconds. If not specified, the global idle_timeout setting is used.</p> <p>Default: <code>None</code> (uses global setting).</p>"},{"location":"reference/pool/#server_lifetime","title":"server_lifetime","text":"<p>Close server connections in this pool that have been opened for longer than this value, in milliseconds. Only applied to idle connections. If not specified, the global server_lifetime setting is used.</p> <p>Default: <code>None</code> (uses global setting).</p>"},{"location":"reference/pool/#pool_mode","title":"pool_mode","text":"<ul> <li> <p><code>session</code> :   Server is released back to pool after client disconnects.</p> </li> <li> <p><code>transaction</code> :   Server is released back to pool after transaction finishes.</p> </li> </ul> <p>Example: <code>\"session\"</code> or <code>\"transaction\"</code>.</p>"},{"location":"reference/pool/#log_client_parameter_status_changes","title":"log_client_parameter_status_changes","text":"<p>Log information about any SET command in the log.</p> <p>Default: <code>false</code>.</p>"},{"location":"reference/pool/#cleanup_server_connections","title":"cleanup_server_connections","text":"<p>When enabled, the pool will automatically clean up server connections that are no longer needed. This helps manage resources efficiently by closing idle connections.</p> <p>Default: <code>true</code>.</p>"},{"location":"reference/pool/#pool-users-settings","title":"Pool Users Settings","text":"<pre><code>[pools.exampledb.users.0]\nusername = \"exampledb-user-0\" # A virtual user who can connect to this virtual database.\n</code></pre>"},{"location":"reference/pool/#username","title":"username","text":"<p>A virtual username who can connect to this virtual database (pool).</p> <p>Example: <code>\"exampledb-user-0\"</code>.</p>"},{"location":"reference/pool/#password","title":"password","text":"<p>The password for the virtual pool user. Password can be specified in <code>MD5</code>, <code>SCRAM-SHA-256</code>, or <code>JWT</code> format. Also, you can create a mirror list of users using secrets from the PostgreSQL instance: <code>select usename, passwd from pg_shadow</code>.</p> <p>Example: <code>md5dd9a0f2...76a09bbfad</code> or <code>SCRAM-SHA-256$4096:E+QNCSW3r58yM+Twj1P5Uw==$LQrKl...Ro1iBKM=</code> or in jwt format: <code>jwt-pkey-fpath:/etc/pg_doorman/jwt/public-exampledb-user.pem</code></p>"},{"location":"reference/pool/#auth_pam_service","title":"auth_pam_service","text":"<p>The pam-service that is responsible for client authorization. In this case, pg_doorman will ignore the <code>password</code> value.</p>"},{"location":"reference/pool/#server_username","title":"server_username","text":"<p>The real server user of the database who connects to this database.</p> <p>Example: <code>\"exampledb_server_user\"</code>.</p>"},{"location":"reference/pool/#server_password","title":"server_password","text":"<p>The password (plain text) of real server user of the database who connects to this database.</p> <p>Example: <code>\"password\"</code>.</p>"},{"location":"reference/pool/#pool_size","title":"pool_size","text":"<p>The maximum number of simultaneous connections to the PostgreSQL server available for this pool and user.</p> <p>Default: <code>40</code>.</p>"},{"location":"reference/pool/#min_pool_size","title":"min_pool_size","text":"<p>The minimum number of connections to maintain in the pool for this user. This helps with performance by keeping connections ready. If specified, it must be less than or equal to pool_size.</p> <p>Default: <code>None</code>.</p>"},{"location":"reference/pool/#server_lifetime_1","title":"server_lifetime","text":"<p>Close server connections for this user that have been opened for longer than this value, in milliseconds. Only applied to idle connections. If not specified, the pool's server_lifetime setting is used.</p> <p>Default: <code>None</code> (uses pool setting).</p>"},{"location":"reference/prometheus/","title":"Prometheus Settings","text":"<p>pg_doorman includes a Prometheus metrics exporter that provides detailed insights into the performance and behavior of your connection pools. This document describes how to enable and use the Prometheus metrics exporter, as well as the available metrics.</p>"},{"location":"reference/prometheus/#enabling-prometheus-metrics","title":"Enabling Prometheus Metrics","text":"<p>To enable the Prometheus metrics exporter, add the following configuration to your <code>pg_doorman.toml</code> file:</p> <pre><code>[prometheus]\nenabled = true\nhost = \"0.0.0.0\"  # The host on which the metrics server will listen\nport = 9127       # The port on which the metrics server will listen\n</code></pre>"},{"location":"reference/prometheus/#configuration-options","title":"Configuration Options","text":"Option Description Default <code>enabled</code> Enable or disable the Prometheus metrics exporter <code>false</code> <code>host</code> The host on which the Prometheus metrics exporter will listen <code>\"0.0.0.0\"</code> <code>port</code> The port on which the Prometheus metrics exporter will listen <code>9127</code>"},{"location":"reference/prometheus/#configuring-prometheus","title":"Configuring Prometheus","text":"<p>Add the following job to your Prometheus configuration to scrape metrics from pg_doorman:</p> <pre><code>scrape_configs:\n  - job_name: 'pg_doorman'\n    static_configs:\n      - targets: ['&lt;pg_doorman_host&gt;:9127']\n</code></pre> <p>Replace <code>&lt;pg_doorman_host&gt;</code> with the hostname or IP address of your pg_doorman instance.</p>"},{"location":"reference/prometheus/#available-metrics","title":"Available Metrics","text":"<p>pg_doorman exposes the following metrics:</p>"},{"location":"reference/prometheus/#system-metrics","title":"System Metrics","text":"Metric Description <code>pg_doorman_total_memory</code> Total memory allocated to the pg_doorman process in bytes. Monitors the memory footprint of the application."},{"location":"reference/prometheus/#connection-metrics","title":"Connection Metrics","text":"Metric Description <code>pg_doorman_connection_count</code> Counter of new connections by type handled by pg_doorman. Types include: 'plain' (unencrypted connections), 'tls' (encrypted connections), 'cancel' (connection cancellation requests), and 'total' (sum of all connections)."},{"location":"reference/prometheus/#socket-metrics-linux-only","title":"Socket Metrics (Linux only)","text":"Metric Description <code>pg_doorman_sockets</code> Counter of sockets used by pg_doorman by socket type. Types include: 'tcp' (IPv4 TCP sockets), 'tcp6' (IPv6 TCP sockets), 'unix' (Unix domain sockets), and 'unknown' (sockets of unrecognized type). Only available on Linux systems."},{"location":"reference/prometheus/#pool-metrics","title":"Pool Metrics","text":"Metric Description <code>pg_doorman_pools_clients</code> Number of clients in connection pools by status, user, and database. Status values include: 'idle' (connected but not executing queries), 'waiting' (waiting for a server connection), and 'active' (currently executing queries). Helps monitor connection pool utilization and client distribution. <code>pg_doorman_pools_servers</code> Number of servers in connection pools by status, user, and database. Status values include: 'active' (actively serving clients) and 'idle' (available for new connections). Helps monitor server availability and load distribution. <code>pg_doorman_pools_bytes</code> Total bytes transferred through connection pools by direction, user, and database. Direction values include: 'received' (bytes received from clients) and 'sent' (bytes sent to clients). Useful for monitoring network traffic and identifying high-volume connections."},{"location":"reference/prometheus/#query-and-transaction-metrics","title":"Query and Transaction Metrics","text":"Metric Description <code>pg_doorman_pools_queries_percentile</code> Query execution time percentiles by user and database. Percentile values include: '99', '95', '90', and '50' (median). Values are in milliseconds. Helps identify slow queries and performance trends across different users and databases. <code>pg_doorman_pools_transactions_percentile</code> Transaction execution time percentiles by user and database. Percentile values include: '99', '95', '90', and '50' (median). Values are in milliseconds. Helps monitor transaction performance and identify long-running transactions that might impact database performance. <code>pg_doorman_pools_transactions_count</code> Counter of transactions executed in connection pools by user and database. Helps track transaction volume and identify users or databases with high transaction rates. <code>pg_doorman_pools_transactions_total_time</code> Total time spent executing transactions in connection pools by user and database. Values are in milliseconds. Helps monitor overall transaction performance and identify users or databases with high transaction execution times. <code>pg_doorman_pools_queries_count</code> Counter of queries executed in connection pools by user and database. Helps track query volume and identify users or databases with high query rates. <code>pg_doorman_pools_queries_total_time</code> Total time spent executing queries in connection pools by user and database. Values are in milliseconds. Helps monitor overall query performance and identify users or databases with high query execution times. <code>pg_doorman_pools_avg_wait_time</code> Average wait time for clients in connection pools by user and database. Values are in milliseconds. Helps monitor client wait times and identify potential bottlenecks."},{"location":"reference/prometheus/#server-metrics","title":"Server Metrics","text":"Metric Description <code>pg_doorman_servers_prepared_hits</code> Counter of prepared statement hits in databases backends by user and database. Helps track the effectiveness of prepared statements in reducing query parsing overhead. <code>pg_doorman_servers_prepared_misses</code> Counter of prepared statement misses in databases backends by user and database. Helps identify queries that could benefit from being prepared to improve performance."},{"location":"reference/prometheus/#grafana-dashboard","title":"Grafana Dashboard","text":"<p>You can create a Grafana dashboard to visualize these metrics. Here's a simple example of panels you might want to include:</p> <ol> <li>Connection counts by type</li> <li>Memory usage over time</li> <li>Client and server counts by pool</li> <li>Query and transaction performance percentiles</li> <li>Network traffic by pool</li> </ol>"},{"location":"reference/prometheus/#example-queries","title":"Example Queries","text":"<p>Here are some example Prometheus queries that you might find useful:</p>"},{"location":"reference/prometheus/#connection-rate","title":"Connection Rate","text":"<pre><code>rate(pg_doorman_connection_count{type=\"total\"}[5m])\n</code></pre>"},{"location":"reference/prometheus/#pool-utilization","title":"Pool Utilization","text":"<pre><code>sum by (database) (pg_doorman_pools_clients{status=\"active\"}) / sum by (database) (pg_doorman_pools_servers{status=\"active\"} + pg_doorman_pools_servers{status=\"idle\"})\n</code></pre>"},{"location":"reference/prometheus/#slow-queries","title":"Slow Queries","text":"<pre><code>pg_doorman_pools_queries_percentile{percentile=\"99\"}\n</code></pre>"},{"location":"reference/prometheus/#client-wait-time","title":"Client Wait Time","text":"<pre><code>pg_doorman_pools_avg_wait_time\n</code></pre>"},{"location":"tutorials/basic-usage/","title":"PgDoorman Basic Usage Guide","text":"<p>PgDoorman is a high-performance PostgreSQL connection pooler based on PgCat. This comprehensive guide will help you get started with configuring, running, and managing PgDoorman for your PostgreSQL environment.</p>"},{"location":"tutorials/basic-usage/#command-line-options","title":"Command Line Options","text":"<p>PgDoorman offers several command-line options to customize its behavior when starting the service:</p> <pre><code>$ pg_doorman --help\n\nPgDoorman: Nextgen PostgreSQL Pooler (based on PgCat)\n\nUsage: pg_doorman [OPTIONS] [CONFIG_FILE] [COMMAND]\n\nCommands:\n  generate  Generate configuration for pg_doorman by connecting to PostgreSQL and auto-detecting databases and users\n  help      Print this message or the help of the given subcommand(s)\n\nArguments:\n  [CONFIG_FILE]  [env: CONFIG_FILE=] [default: pg_doorman.toml]\n\nOptions:\n  -l, --log-level &lt;LOG_LEVEL&gt;    [env: LOG_LEVEL=] [default: INFO]\n  -F, --log-format &lt;LOG_FORMAT&gt;  [env: LOG_FORMAT=] [default: text] [possible values: text, structured, debug]\n  -n, --no-color                 disable colors in the log output [env: NO_COLOR=]\n  -d, --daemon                   run as daemon [env: DAEMON=]\n  -h, --help                     Print help\n  -V, --version                  Print version\n</code></pre>"},{"location":"tutorials/basic-usage/#available-options","title":"Available Options","text":"Option Description <code>-d</code>, <code>--daemon</code> Run in the background. Without this option, the process will run in the foreground.In daemon mode, setting <code>daemon_pid_file</code> and <code>syslog_prog_name</code> is required. No log messages will be written to stderr after going into the background. <code>-l</code>, <code>--log-level</code> Set log level: <code>INFO</code>, <code>DEBUG</code>, or <code>WARN</code>. <code>-F</code>, <code>--log-format</code> Set log format. Possible values: <code>text</code>, <code>structured</code>, <code>debug</code>. <code>-n</code>, <code>--no-color</code> Disable colors in the log output. <code>-V</code>, <code>--version</code> Show version information. <code>-h</code>, <code>--help</code> Show help information."},{"location":"tutorials/basic-usage/#setup-and-configuration","title":"Setup and Configuration","text":""},{"location":"tutorials/basic-usage/#configuration-file-structure","title":"Configuration File Structure","text":"<p>PgDoorman uses a TOML format configuration file to define its behavior. The configuration file is organized into several sections:</p> <ul> <li><code>[general]</code> - Global settings for the PgDoorman service</li> <li><code>[pools]</code> - Database pool definitions</li> <li><code>[pools.&lt;name&gt;]</code> - Settings for a specific database pool</li> <li><code>[pools.&lt;name&gt;.users.&lt;n&gt;]</code> - User settings for a specific database pool</li> </ul> <p>Important</p> <p>Some parameters must be specified in the configuration file for PgDoorman to start, even if they have default values. For example, you must specify an admin username and password to access the administrative console.</p>"},{"location":"tutorials/basic-usage/#minimal-configuration-example","title":"Minimal Configuration Example","text":"<p>Here's a minimal configuration example to get you started:</p> <pre><code># Global settings\n[general]\nhost = \"0.0.0.0\"    # Listen on all interfaces\nport = 6432         # Port for client connections\n\n# Admin credentials for the management console\nadmin_username = \"admin\"\nadmin_password = \"admin\"  # Change this in production!\n\n# Database pools section\n[pools]\n\n# Example database pool\n[pools.exampledb]\nserver_host = \"127.0.0.1\"  # PostgreSQL server address\nserver_port = 5432         # PostgreSQL server port\npool_mode = \"transaction\"  # Connection pooling mode\n\n# User configuration for this pool\n[pools.exampledb.users.0]\npool_size = 40             # Maximum number of connections in the pool\nusername = \"doorman\"       # Username for PostgreSQL server\npassword = \"SCRAM-SHA-256$4096:6nD+Ppi9rgaNyP7...MBiTld7xJipwG/X4=\"  # Hashed password\n</code></pre> <p>For a complete list of configuration options and their descriptions, see the Settings Reference Guide.</p>"},{"location":"tutorials/basic-usage/#automatic-configuration-generation","title":"Automatic Configuration Generation","text":"<p>PgDoorman provides a powerful <code>generate</code> command that can automatically create a configuration file by connecting to your PostgreSQL server and detecting databases and users:</p> <pre><code># View all available options\npg_doorman generate --help\n\n# Generate a configuration file with default settings\npg_doorman generate --output pg_doorman.toml\n</code></pre> <p>The <code>generate</code> command supports several options:</p> Option Description <code>--host</code> PostgreSQL host to connect to (uses localhost if not specified) <code>--port</code>, <code>-p</code> PostgreSQL port to connect to (default: 5432) <code>--user</code>, <code>-u</code> PostgreSQL user to connect as (requires superuser privileges to read pg_shadow) <code>--password</code> PostgreSQL password to connect with <code>--database</code>, <code>-d</code> PostgreSQL database to connect to (uses same name as user if not specified) <code>--ssl</code> PostgreSQL connection to server via SSL/TLS <code>--pool-size</code> Pool size for the generated configuration (default: 40) <code>--session-pool-mode</code>, <code>-s</code> Session pool mode for the generated configuration <code>--output</code>, <code>-o</code> Output file for the generated configuration (uses stdout if not specified) <code>--server-host</code> Override server_host in config (uses the host parameter if not specified) <p>The command connects to your PostgreSQL server, automatically detects all databases and users, and creates a complete configuration file with appropriate settings. This is especially useful for quickly setting up PgDoorman in new environments or when you have many databases and users to configure.</p> <p>PostgreSQL Environment Variables</p> <p>The <code>generate</code> command also respects standard PostgreSQL environment variables like <code>PGHOST</code>, <code>PGPORT</code>, <code>PGUSER</code>, <code>PGPASSWORD</code>, and <code>PGDATABASE</code>.</p> <p>Authentication Required</p> <p>If your PostgreSQL server requires authentication in pg_hba.conf, you will need to manually set the <code>server_password</code> parameter in the configuration file after using the <code>generate</code> command.</p> <p>Superuser Privileges</p> <p>Reading user information from PostgreSQL requires superuser privileges to access the <code>pg_shadow</code> table.</p>"},{"location":"tutorials/basic-usage/#running-pgdoorman","title":"Running PgDoorman","text":"<p>After creating your configuration file, you can run PgDoorman from the command line:</p> <pre><code>$ pg_doorman pg_doorman.toml\n</code></pre> <p>If you don't specify a configuration file, PgDoorman will look for <code>pg_doorman.toml</code> in the current directory.</p>"},{"location":"tutorials/basic-usage/#connecting-to-postgresql-via-pgdoorman","title":"Connecting to PostgreSQL via PgDoorman","text":"<p>Once PgDoorman is running, connect to it instead of connecting directly to your PostgreSQL database:</p> <pre><code>$ psql -h localhost -p 6432 -U doorman exampledb\n</code></pre> <p>Your application's connection string should be updated to point to PgDoorman instead of directly to PostgreSQL:</p> <pre><code>postgresql://doorman:password@localhost:6432/exampledb\n</code></pre> <p>PgDoorman will handle the connection pooling transparently, so your application doesn't need to be aware that it's connecting through a pooler.</p>"},{"location":"tutorials/basic-usage/#administration","title":"Administration","text":""},{"location":"tutorials/basic-usage/#admin-console","title":"Admin Console","text":"<p>PgDoorman provides a powerful administrative interface that allows you to monitor and manage the connection pooler. You can access this interface by connecting to the special administration database named pgdoorman:</p> <pre><code>$ psql -h localhost -p 6432 -U admin pgdoorman\n</code></pre> <p>Once connected, you can view available commands:</p> <pre><code>pgdoorman=&gt; SHOW HELP;\nNOTICE:  Console usage\nDETAIL:\n    SHOW HELP|CONFIG|DATABASES|POOLS|POOLS_EXTENDED|CLIENTS|SERVERS|USERS|VERSION\n    SHOW LISTS\n    SHOW CONNECTIONS\n    SHOW STATS\n    RELOAD\n    SHUTDOWN\n    SHOW\n</code></pre> <p>Protocol Compatibility</p> <p>The admin console currently supports only the simple query protocol. Some database drivers use the extended query protocol for all commands, making them unsuitable for admin console access. In such cases, use the <code>psql</code> command-line client for administration.</p> <p>Security</p> <p>Only the user specified by <code>admin_username</code> in the configuration file is allowed to log in to the admin console.  Make sure to use a strong password for this account in production environments.</p>"},{"location":"tutorials/basic-usage/#monitoring-pgdoorman","title":"Monitoring PgDoorman","text":"<p>The admin console provides several commands to monitor the current state of PgDoorman:</p> <ul> <li><code>SHOW STATS</code> - View performance statistics</li> <li><code>SHOW CLIENTS</code> - List current client connections</li> <li><code>SHOW SERVERS</code> - List current server connections</li> <li><code>SHOW POOLS</code> - View connection pool status</li> <li><code>SHOW DATABASES</code> - List configured databases</li> <li><code>SHOW USERS</code> - List configured users</li> </ul> <p>These commands are described in detail in the Admin Console Commands section below.</p>"},{"location":"tutorials/basic-usage/#reloading-configuration","title":"Reloading Configuration","text":"<p>If you make changes to the <code>pg_doorman.toml</code> file, you can apply them without restarting the service:</p> <pre><code>pgdoorman=# RELOAD;\n</code></pre> <p>When you reload the configuration:</p> <ol> <li>PgDoorman reads the updated configuration file</li> <li>Changes to database connection parameters are detected</li> <li>Existing server connections are closed when they're next released (according to the pooling mode)</li> <li>New server connections immediately use the updated parameters</li> </ol> <p>This allows you to make configuration changes with minimal disruption to your applications.</p>"},{"location":"tutorials/basic-usage/#admin-console-commands","title":"Admin Console Commands","text":"<p>The admin console provides a set of commands to monitor and manage PgDoorman. These commands follow a SQL-like syntax and can be executed from any PostgreSQL client connected to the admin console.</p>"},{"location":"tutorials/basic-usage/#show-commands","title":"Show Commands","text":"<p>The <code>SHOW</code> commands display information about PgDoorman's operation. Each command provides different insights into the pooler's performance and current state.</p>"},{"location":"tutorials/basic-usage/#show-stats","title":"SHOW STATS","text":"<p>The <code>SHOW STATS</code> command displays comprehensive statistics about PgDoorman's operation:</p> <pre><code>pgdoorman=&gt; SHOW STATS;\n</code></pre> <p>Statistics are presented per database with the following metrics:</p> Metric Description <code>database</code> The database name these statistics apply to <code>total_xact_count</code> Total number of SQL transactions processed since startup <code>total_query_count</code> Total number of SQL commands processed since startup <code>total_received</code> Total bytes of network traffic received from clients <code>total_sent</code> Total bytes of network traffic sent to clients <code>total_xact_time</code> Total microseconds spent in transactions (including idle in transaction) <code>total_query_time</code> Total microseconds spent actively executing queries <code>total_wait_time</code> Total microseconds clients spent waiting for a server connection <code>avg_xact_count</code> Average transactions per second in the last 15-second period <code>avg_query_count</code> Average queries per second in the last 15-second period <code>avg_server_assignment_count</code> Average server assignments per second in the last 15-second period <code>avg_recv</code> Average bytes received per second from clients <code>avg_sent</code> Average bytes sent per second to clients <code>avg_xact_time</code> Average transaction duration in microseconds <code>avg_query_time</code> Average query duration in microseconds <code>avg_wait_time</code> Average time clients spent waiting for a server in microseconds <p>Performance Monitoring</p> <p>Pay special attention to the <code>avg_wait_time</code> metric. If this value is consistently high, it may indicate that your pool size is too small for your workload.</p>"},{"location":"tutorials/basic-usage/#show-servers","title":"SHOW SERVERS","text":"<p>The <code>SHOW SERVERS</code> command displays detailed information about all server connections:</p> <pre><code>pgdoorman=&gt; SHOW SERVERS;\n</code></pre> Column Description <code>server_id</code> Unique identifier for the server connection <code>server_process_id</code> PID of the backend PostgreSQL server process (if available) <code>database_name</code> Name of the database this connection is using <code>user</code> Username PgDoorman uses to connect to the PostgreSQL server <code>application_name</code> Value of the <code>application_name</code> parameter set on the server connection <code>state</code> Current state of the connection: active, idle, or used <code>wait</code> Wait state of the connection: idle, read, or write <code>transaction_count</code> Total number of transactions processed by this connection <code>query_count</code> Total number of queries processed by this connection <code>bytes_sent</code> Total bytes sent to the PostgreSQL server <code>bytes_received</code> Total bytes received from the PostgreSQL server <code>age_seconds</code> Lifetime of the current server connection in seconds <code>prepare_cache_hit</code> Number of prepared statement cache hits <code>prepare_cache_miss</code> Number of prepared statement cache misses <code>prepare_cache_size</code> Number of unique prepared statements in the cache <p>Connection States</p> <ul> <li>active: The connection is currently executing a query</li> <li>idle: The connection is available for use</li> <li>used: The connection is allocated to a client but not currently executing a query</li> </ul>"},{"location":"tutorials/basic-usage/#show-clients","title":"SHOW CLIENTS","text":"<p>The <code>SHOW CLIENTS</code> command displays information about all client connections to PgDoorman:</p> <pre><code>pgdoorman=&gt; SHOW CLIENTS;\n</code></pre> Column Description <code>client_id</code> Unique identifier for the client connection <code>database</code> Name of the database (pool) the client is connected to <code>user</code> Username the client used to connect <code>addr</code> Client's IP address and port (IP:port) <code>tls</code> Whether the connection uses TLS encryption (true or false) <code>state</code> Current state of the client connection: active, idle, or waiting <code>wait</code> Wait state of the client connection: idle, read, or write <code>transaction_count</code> Total number of transactions processed for this client <code>query_count</code> Total number of queries processed for this client <code>age_seconds</code> Lifetime of the client connection in seconds <p>Monitoring Long-Running Connections</p> <p>The <code>age_seconds</code> column can help identify long-running connections that might be holding resources unnecessarily. Consider implementing connection timeouts in your application for idle connections.</p>"},{"location":"tutorials/basic-usage/#show-pools","title":"SHOW POOLS","text":"<p>The <code>SHOW POOLS</code> command displays information about connection pools. A new pool entry is created for each (database, user) pair:</p> <pre><code>pgdoorman=&gt; SHOW POOLS;\n</code></pre> Column Description <code>database</code> Name of the database <code>user</code> Username associated with this pool <code>pool_mode</code> Pooling mode in use: session or transaction <code>cl_active</code> Number of active client connections (linked to servers or idle) <code>cl_waiting</code> Number of client connections waiting for a server connection <code>sv_active</code> Number of server connections linked to clients <code>sv_idle</code> Number of idle server connections available for immediate use <code>sv_login</code> Number of server connections currently in the login process <code>maxwait</code> Maximum wait time in seconds for the oldest client in the queue <code>maxwait_us</code> Microsecond part of the maximum waiting time <p>Performance Alert</p> <p>If the <code>maxwait</code> value starts increasing, your server pool may not be handling requests quickly enough. This could be due to an overloaded PostgreSQL server or insufficient <code>pool_size</code> setting.</p>"},{"location":"tutorials/basic-usage/#show-users","title":"SHOW USERS","text":"<p>The <code>SHOW USERS</code> command displays information about all configured users:</p> <pre><code>pgdoorman=&gt; SHOW USERS;\n</code></pre> Column Description <code>name</code> Username as configured in PgDoorman <code>pool_mode</code> Pooling mode assigned to this user: session or transaction"},{"location":"tutorials/basic-usage/#show-databases","title":"SHOW DATABASES","text":"<p>The <code>SHOW DATABASES</code> command displays information about all configured database pools:</p> <pre><code>pgdoorman=&gt; SHOW DATABASES;\n</code></pre> Column Description <code>database</code> Name of the configured database pool <code>host</code> Hostname of the PostgreSQL server PgDoorman connects to <code>port</code> Port number of the PostgreSQL server <code>pool_size</code> Maximum number of server connections for this database <code>min_pool_size</code> Minimum number of server connections to maintain <code>reserve_pool_size</code> Maximum number of additional connections allowed <code>pool_mode</code> Default pooling mode for this database <code>max_connections</code> Maximum allowed server connections (from <code>max_db_connections</code>) <code>current_connections</code> Current number of server connections for this database <p>Connection Management</p> <p>Monitor the ratio between <code>current_connections</code> and <code>pool_size</code> to ensure your pool is properly sized. If <code>current_connections</code> frequently reaches <code>pool_size</code>, consider increasing the pool size.</p>"},{"location":"tutorials/basic-usage/#show-sockets","title":"SHOW SOCKETS","text":"<p>The <code>SHOW SOCKETS</code> command displays low-level information about network sockets:</p> <pre><code>pgdoorman=&gt; SHOW SOCKETS;\n</code></pre> <p>This command includes all information shown in <code>SHOW CLIENTS</code> and <code>SHOW SERVERS</code> plus additional low-level details about the socket connections.</p>"},{"location":"tutorials/basic-usage/#show-version","title":"SHOW VERSION","text":"<p>The <code>SHOW VERSION</code> command displays the PgDoorman version information:</p> <pre><code>pgdoorman=&gt; SHOW VERSION;\n</code></pre> <p>This is useful for verifying which version you're running, especially after upgrades.</p>"},{"location":"tutorials/basic-usage/#control-commands","title":"Control Commands","text":"<p>PgDoorman provides control commands that allow you to manage the service operation directly from the admin console.</p>"},{"location":"tutorials/basic-usage/#shutdown","title":"SHUTDOWN","text":"<p>The <code>SHUTDOWN</code> command gracefully terminates the PgDoorman process:</p> <pre><code>pgdoorman=&gt; SHUTDOWN;\n</code></pre> <p>When executed:</p> <ol> <li>PgDoorman stops accepting new client connections</li> <li>Existing transactions are allowed to complete (within the configured timeout)</li> <li>All connections are closed</li> <li>The process exits</li> </ol> <p>Service Interruption</p> <p>Using the <code>SHUTDOWN</code> command will terminate the PgDoorman service, disconnecting all clients. Use this command with caution in production environments.</p>"},{"location":"tutorials/basic-usage/#reload","title":"RELOAD","text":"<p>The <code>RELOAD</code> command refreshes PgDoorman's configuration without restarting the service:</p> <pre><code>pgdoorman=&gt; RELOAD;\n</code></pre> <p>This command:</p> <ol> <li>Rereads the configuration file</li> <li>Updates all changeable settings</li> <li>Applies changes to connection parameters for new connections</li> <li>Maintains existing connections until they're released back to the pool</li> </ol> <p>Zero-Downtime Configuration Changes</p> <p>The <code>RELOAD</code> command allows you to modify most configuration parameters without disrupting existing connections. This is ideal for production environments where downtime must be minimized.</p>"},{"location":"tutorials/basic-usage/#signal-handling","title":"Signal Handling","text":"<p>PgDoorman responds to standard Unix signals for control and management. These signals can be sent using the <code>kill</code> command (e.g., <code>kill -HUP &lt;pid&gt;</code>).</p> Signal Description Effect SIGHUP Configuration reload Equivalent to the <code>RELOAD</code> command in the admin console. Rereads the configuration file and applies changes to settings. SIGTERM Immediate shutdown Forces PgDoorman to exit immediately. Active connections may be terminated abruptly. SIGINT Graceful shutdown Initiates a binary upgrade process. The current process starts a new instance and gracefully transfers connections. See Binary Upgrade Process for details. <p>Process Management</p> <p>In systemd-based environments, you can use <code>systemctl reload pg_doorman</code> to send SIGHUP and <code>systemctl restart pg_doorman</code> for a complete restart.</p>"},{"location":"tutorials/binary-upgrade/","title":"Binary Upgrade Process","text":""},{"location":"tutorials/binary-upgrade/#overview","title":"Overview","text":"<p>PgDoorman supports seamless binary upgrades that allow you to update the software with minimal disruption to your database connections. This document explains how the upgrade process works and what to expect during an upgrade.</p>"},{"location":"tutorials/binary-upgrade/#how-the-upgrade-process-works","title":"How the Upgrade Process Works","text":"<p>When you send a <code>SIGINT</code> signal to the PgDoorman process, the binary upgrade process is initiated:</p> <ol> <li>The current PgDoorman instance executes the exec command and starts a new, daemonized process</li> <li>The new process uses the <code>SO_REUSE_PORT</code> socket option, allowing the operating system to distribute incoming traffic to the new instance</li> <li>The old instance then closes its socket for incoming connections</li> <li>Existing connections are handled gracefully during the transition</li> </ol>"},{"location":"tutorials/binary-upgrade/#handling-existing-connections","title":"Handling Existing Connections","text":"<p>During the upgrade process, PgDoorman handles existing connections as follows:</p> <ol> <li>Current queries and transactions are allowed to complete within the specified <code>shutdown_timeout</code> (default: 10 seconds)</li> <li>After each query or transaction completes successfully, PgDoorman returns error code <code>58006</code> to the client</li> <li>This error code indicates to the client that they need to reconnect to the server</li> <li>After reconnecting, clients can safely retry their queries with the new PgDoorman instance</li> </ol>"},{"location":"tutorials/binary-upgrade/#important-considerations","title":"Important Considerations","text":"<p>Query Repetition</p> <p>Repeating a query without receiving error code <code>58006</code> may cause problems as described in this issue. Make sure your client application properly handles reconnection scenarios.</p> <p>Client Library Compatibility</p> <p>Be careful when using client libraries like <code>github.com/lib/pq</code> or Go's standard <code>database/sql</code> package. Ensure they properly handle the reconnection process during binary upgrades.</p>"},{"location":"tutorials/contributing/","title":"Contributing to PgDoorman","text":"<p>Thank you for your interest in contributing to PgDoorman! This guide will help you set up your development environment and understand the contribution process.</p>"},{"location":"tutorials/contributing/#getting-started","title":"Getting Started","text":""},{"location":"tutorials/contributing/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have the following installed:</p> <ul> <li>Rust (latest stable version)</li> <li>Git</li> <li>Docker (optional, for running tests)</li> <li>Make (optional, for running test scripts)</li> </ul>"},{"location":"tutorials/contributing/#setting-up-your-development-environment","title":"Setting Up Your Development Environment","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork:    <pre><code>git clone https://github.com/YOUR-USERNAME/pg_doorman.git\ncd pg_doorman\n</code></pre></li> <li>Add the upstream repository:    <pre><code>git remote add upstream https://github.com/ozontech/pg_doorman.git\n</code></pre></li> </ol>"},{"location":"tutorials/contributing/#local-development","title":"Local Development","text":"<ol> <li> <p>Build the project:    <pre><code>cargo build\n</code></pre></p> </li> <li> <p>Build for performance testing:    <pre><code>cargo build --release\n</code></pre></p> </li> <li> <p>Configure PgDoorman:</p> </li> <li>Copy the example configuration: <code>cp pg_doorman.toml.example pg_doorman.toml</code></li> <li> <p>Adjust the configuration in <code>pg_doorman.toml</code> to match your setup</p> </li> <li> <p>Run PgDoorman:    <pre><code>cargo run --release\n</code></pre></p> </li> <li> <p>Run tests:    <pre><code>cargo test\n</code></pre></p> </li> <li> <p>Run integration tests with Docker:    <pre><code>make docker-compose-test-all\n</code></pre></p> </li> </ol>"},{"location":"tutorials/contributing/#contribution-guidelines","title":"Contribution Guidelines","text":""},{"location":"tutorials/contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow the Rust style guidelines</li> <li>Use meaningful variable and function names</li> <li>Add comments for complex logic</li> <li>Write tests for new functionality</li> </ul>"},{"location":"tutorials/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Create a new branch for your feature or bugfix</li> <li>Make your changes and commit them with clear, descriptive messages</li> <li>Write or update tests as necessary</li> <li>Update documentation to reflect any changes</li> <li>Submit a pull request to the main repository</li> <li>Address any feedback from code reviews</li> </ol>"},{"location":"tutorials/contributing/#reporting-issues","title":"Reporting Issues","text":"<p>If you find a bug or have a feature request, please create an issue on the GitHub repository with:</p> <ul> <li>A clear, descriptive title</li> <li>A detailed description of the issue or feature</li> <li>Steps to reproduce (for bugs)</li> <li>Expected and actual behavior (for bugs)</li> </ul>"},{"location":"tutorials/contributing/#getting-help","title":"Getting Help","text":"<p>If you need help with your contribution, you can:</p> <ul> <li>Ask questions in the GitHub issues</li> <li>Reach out to the maintainers</li> </ul> <p>Thank you for contributing to PgDoorman!</p>"},{"location":"tutorials/installation/","title":"Installing PgDoorman","text":"<p>This guide covers different methods for installing and running PgDoorman on your system.</p>"},{"location":"tutorials/installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Linux (recommended) or macOS</li> <li>PostgreSQL server (version 10 or higher)</li> <li>Sufficient memory for connection pooling (depends on expected load)</li> </ul>"},{"location":"tutorials/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"tutorials/installation/#pre-built-binaries-recommended","title":"Pre-built Binaries (Recommended)","text":"<p>The simplest way to install PgDoorman is to download a pre-built binary from the GitHub releases page.</p> <ol> <li>Download the appropriate binary for your platform</li> <li>Make the file executable: <code>chmod +x pg_doorman</code></li> <li>Move it to a directory in your PATH: <code>sudo mv pg_doorman /usr/local/bin/</code></li> <li>Create a configuration file (see Basic Usage for details)</li> </ol>"},{"location":"tutorials/installation/#building-from-source","title":"Building from Source","text":"<p>If you prefer to build from source, you'll need to clone the repository first:</p> <pre><code>git clone https://github.com/ozontech/pg_doorman.git\ncd pg_doorman\n</code></pre> <p>Then follow the instructions in the Contributing guide to build the project.</p>"},{"location":"tutorials/installation/#docker-installation","title":"Docker Installation","text":""},{"location":"tutorials/installation/#using-the-official-docker-image-recommended","title":"Using the Official Docker Image (Recommended)","text":"<p>PgDoorman provides an official Docker image that you can use directly:</p> <pre><code># Pull the official Docker image\ndocker pull ghcr.io/ozontech/pg_doorman\n\n# Run PgDoorman with your configuration\ndocker run -p 6432:6432 \\\n  -v /path/to/pg_doorman.toml:/etc/pg_doorman/pg_doorman.toml \\\n  --rm -t -i ghcr.io/ozontech/pg_doorman\n</code></pre>"},{"location":"tutorials/installation/#using-the-dockerfile","title":"Using the Dockerfile","text":"<p>You can build and run PgDoorman using Docker:</p> <pre><code># Build the Docker image\ndocker build -t pg_doorman -f Dockerfile .\n\n# Run PgDoorman with your configuration\ndocker run -p 6432:6432 \\\n  -v /path/to/pg_doorman.toml:/etc/pg_doorman/pg_doorman.toml \\\n  --rm -t -i pg_doorman\n</code></pre>"},{"location":"tutorials/installation/#using-nix-with-docker","title":"Using Nix with Docker","text":"<p>If you use Nix, you can build a Docker image:</p> <pre><code># Build the Docker image using Nix\nnix build .#dockerImage\n\n# Load the image into Docker\ndocker load -i result\n\n# Run PgDoorman with your configuration\ndocker run -p 6432:6432 \\\n  -v /path/to/pg_doorman.toml:/etc/pg_doorman/pg_doorman.toml \\\n  --rm -t -i pg_doorman\n</code></pre>"},{"location":"tutorials/installation/#using-docker-compose-or-podman-compose","title":"Using Docker Compose or Podman Compose","text":"<p>For a more complete setup including PostgreSQL, you can use Docker Compose or Podman Compose.</p> <p>A minimal compose configuration file is available in the repository examples directory.</p>"},{"location":"tutorials/installation/#running-with-docker-compose","title":"Running with Docker Compose","text":"<pre><code>docker compose up -d\n</code></pre>"},{"location":"tutorials/installation/#running-with-podman-compose","title":"Running with Podman Compose","text":"<pre><code>podman-compose up -d\n</code></pre>"},{"location":"tutorials/installation/#verifying-installation","title":"Verifying Installation","text":"<p>After installation, you can verify that PgDoorman is running correctly by:</p> <ol> <li>Checking the process: <code>ps aux | grep pg_doorman</code></li> <li>Connecting to the admin console: <code>psql -h localhost -p 6432 -U admin pgdoorman</code></li> <li>Running <code>SHOW VERSION;</code> in the admin console</li> </ol>"},{"location":"tutorials/installation/#next-steps","title":"Next Steps","text":"<p>After installation, see the Basic Usage guide to configure and start using PgDoorman.</p>"},{"location":"tutorials/overview/","title":"PgDoorman Overview","text":""},{"location":"tutorials/overview/#what-is-pgdoorman","title":"What is PgDoorman?","text":"<p>PgDoorman is a high-performance PostgreSQL connection pooler based on PgCat. It acts as a middleware between your applications and PostgreSQL servers, efficiently managing database connections to improve performance and resource utilization.</p> <p>When an application connects to PgDoorman, it behaves exactly like a PostgreSQL server. Behind the scenes, PgDoorman either creates a new connection to the actual PostgreSQL server or reuses an existing connection from its pool, significantly reducing connection overhead.</p>"},{"location":"tutorials/overview/#key-benefits","title":"Key Benefits","text":"<ul> <li>Reduced Connection Overhead: Minimizes the performance impact of establishing new database connections</li> <li>Resource Optimization: Limits the number of connections to your PostgreSQL server</li> <li>Improved Scalability: Allows more client applications to connect to your database</li> <li>Connection Management: Provides tools to monitor and manage database connections</li> </ul>"},{"location":"tutorials/overview/#pooling-modes","title":"Pooling Modes","text":"<p>To maintain proper transaction semantics while providing efficient connection pooling, PgDoorman supports multiple pooling modes:</p>"},{"location":"tutorials/overview/#session-pooling","title":"Session Pooling","text":"<p>In session pooling mode:</p> <ul> <li>Each client is assigned a dedicated server connection for the entire duration of the client connection</li> <li>The server connection remains exclusively allocated to that client until disconnection</li> <li>After the client disconnects, the server connection is released back into the pool for reuse</li> <li>This mode is ideal for applications that rely on session-level features like temporary tables or session variables</li> </ul>"},{"location":"tutorials/overview/#transaction-pooling","title":"Transaction Pooling","text":"<p>In transaction pooling mode:</p> <ul> <li>A client is assigned a server connection only for the duration of a transaction</li> <li>Once PgDoorman detects the end of a transaction, the server connection is immediately released back into the pool</li> <li>This mode allows for higher connection efficiency as connections are shared between clients</li> <li>Ideal for applications with many short-lived connections or those that don't rely on session state</li> </ul>"},{"location":"tutorials/overview/#administration","title":"Administration","text":"<p>PgDoorman provides comprehensive tools for monitoring and management:</p> <ul> <li>Admin Console: A PostgreSQL-compatible interface for viewing statistics and managing the pooler</li> <li>Configuration Options: Extensive settings to customize behavior for your specific needs</li> <li>Monitoring: Detailed metrics about connection usage and performance</li> </ul> <p>For detailed information on managing PgDoorman, see the Admin Console documentation.</p>"}]}